import wave
import requests
import os
import boto3
import configparser
import winsound
from words import trading_keywords, endpoint_phrases
import openai
from oandapyV20 import API
from oandapyV20.endpoints.pricing import PricingStream
import csv
from oandapyV20.exceptions import StreamTerminated
import pandas as pd

# Read keys from config.ini
config = configparser.ConfigParser()
config.read('config.ini')

# Set the OpenAI API key
OPENAI_API_KEY = config.get('API_KEYS', 'OPENAI_API_KEY')
openai.api_key = OPENAI_API_KEY
MAX_TOKENS = 2000  # Adjusted based on GPT-3 model's limitations

# Set the base URL for the OANDA API
BASE_URL = "https://api-fxpractice.oanda.com"
ACCOUNT_ID = "101-001-25836141-002"

# The headers for the HTTP requests
OANDA_API_KEY = config.get('API_KEYS', 'OANDA_API_KEY')
headers = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {OANDA_API_KEY}",
    "Connection": "keep-alive"
}

# Initialize AWS Polly client
AWS_ACCESS_KEY_ID = config.get('AWS_KEYS', 'AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = config.get('AWS_KEYS', 'AWS_SECRET_ACCESS_KEY')
AWS_REGION = config.get('AWS_KEYS', 'AWS_REGION')
session = boto3.Session(
    aws_access_key_id=AWS_ACCESS_KEY_ID,
    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
    region_name=AWS_REGION
)
polly_client = session.client('polly')
# Load data from csv files
streaming_prices = pd.read_csv('C:\\Users\\kingp\\Downloads\\Trading_Pal-main\\streaming_data\\GBP_USD_D.csv')


# Create combined data
combined_data = {
    'streaming_prices': streaming_prices,
    }
# Function to convert text to speech using AWS Polly
def text_to_speech(text):
    response = polly_client.synthesize_speech(
        Text=text,
        OutputFormat="pcm",
        VoiceId="Matthew"  # Provide the desired voice ID
    )
    audio = response['AudioStream'].read()

    # Save the audio stream to a temporary WAV file
    with wave.open("temp.wav", 'wb') as wav_file:
        wav_file.setnchannels(1)
        wav_file.setsampwidth(2)
        wav_file.setframerate(16000)
        wav_file.writeframes(audio)

    # Play the audio using the winsound module
    winsound.PlaySound("temp.wav", winsound.SND_FILENAME)

    # Remove the temporary WAV file
    os.remove("temp.wav")

# Modify the printing statements to use text_to_speech function
def print_with_voice(text):
    print(text)
    text_to_speech(text)


# Function to check if user input is trading-related
def is_trading_related(user_input):
    # Convert the user's input to lowercase
    user_input = user_input.lower()

    # Check if any of the trading keywords are in the user's input
    for keyword in trading_keywords:
        if keyword in user_input:
            return True

    # If no trading keywords were found in the user's input, return False
    return False

# User preferences and username (Dummy values for demonstration)
user_preferences = {
    "risk_tolerance": "extremely high",
    "investment_horizon": "Short term profits using high risk to reward strategies",
    "preferred_instruments": "GBP_USD"
}
username = "dectrick"

def get_account_details(account_id):
    url = f"{BASE_URL}/v3/accounts/{account_id}"
    response = requests.get(url, headers=headers)
    try:
        response.raise_for_status()
        data = response.json()
        
        # Extract only the necessary details
        significant_details = {
            "balance": data["account"]["balance"],
            "marginRate": data["account"]["marginRate"],
            "openTradeCount": data["account"]["openTradeCount"],
            "unrealizedPL": data["account"]["unrealizedPL"],
            # add any other fields you need here
        }
        
        return significant_details
    except requests.exceptions.HTTPError as err:
        raise Exception(f"Failed to get account details. Error: {err}")

# Retrieve account details
account_details = get_account_details(ACCOUNT_ID)


def create_order(ACCOUNT_ID, order_data):
    url = f"{BASE_URL}/v3/accounts/{ACCOUNT_ID}/orders"
    response = requests.post(url, headers=headers, json=order_data)
    try:
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as err:
        error_message = f"Failed to create order. Error: {err}"
        try:
            error_response = response.json()
            error_message += f"\nError details: {error_response}"
        except ValueError:
            pass
        raise Exception(error_message)


# Helper function to extract order parameters
def extract_order_parameters(opportunities):
    action = "BUY" if "BUY" in opportunities else "SELL"
    units = extract_units(opportunities, action)
    forex_pair = extract_forex_pair(opportunities)
    return {"action": action, "units": units, "forex_pair": forex_pair}

# Function to create an order based on parameters
def create_order_based_on_params(order_params):
    order_data = {
        "order": {
            "units": order_params["units"],
            "instrument": order_params["forex_pair"],
            "timeInForce": "FOK",
            "type": "LIMIT",
            "positionFill": "DEFAULT",
            "price": ""
        }
    }

    if order_params["action"] == "SELL":
        order_data["order"]["units"] = "-" + order_params["units"]

    response = create_order(ACCOUNT_ID, order_data)
    if "orderCreateTransaction" in response:
        print_with_voice(f"Order successfully created with ID: {response['orderCreateTransaction']['id']}")
    else:
        print_with_voice("Failed to create order.")

# Function to combine all data from different sources
def combine_all_data():
    # Load data from csv files
    streaming_prices = pd.read_csv('C:\\Users\\kingp\\Downloads\\Trading_Pal-main\\streaming_data\\GBP_USD_D.csv')
    combined_data = {
        'streaming_prices': streaming_prices.to_dict(),
       
    }

    return combined_data



# Helper functions to extract parameter values from opportunities
def extract_units(opportunities, action):
    start_index = opportunities.find(action) + len(action)
    end_index = opportunities.find("units", start_index)
    units = opportunities[start_index:end_index].strip()
    return units

def extract_forex_pair(opportunities):
    forex_pair_start_index = opportunities.find("of") + len("of")
    forex_pair_end_index = opportunities.find("\n", forex_pair_start_index)
    forex_pair = opportunities[forex_pair_start_index:forex_pair_end_index].strip()
    return forex_pair


import re

def extract_order_parameters(opportunities):
    order_params = {
        "order_type": None,
        "forex_pair": None,
        "units": None,
        "price": None,
        "take_profit_price": None,
        "stop_loss_price": None,
        "guaranteed_stop_loss_price": None,
        "trailing_stop_loss_distance": None
    }
    
    # Use regex patterns to extract the parameters
    for param in order_params.keys():
        pattern = f"{param}: \((.*?)\)"
        match = re.search(pattern, opportunities, re.IGNORECASE)
        if match:
            order_params[param] = match.group(1)

    # Error checking
    if None in order_params.values():
        missing_params = [k for k, v in order_params.items() if v is None]
        raise ValueError(f"Missing parameters in opportunities: {missing_params}")
    
    return order_params

def identify_opportunities(combined_data):
    # Assuming combined_data is a dict with various indicators as keys
    combined_data_str = '\n'.join([f"{key}: {value}" for key, value in combined_data.items()])

    # Check data length
    combined_data_str = combined_data_str[:10000]  # trim the data string to 16000 characters

    # Create the prompt for Trading Pal
    prompt = f"""
    You are Trading Pal, a highly advanced trading AI system developed by ProfitWave. Your key mission is to process and analyze real-time market data, and more importantly, use this information to predict potential future movements.

    A stream of historical data has been received:
    {combined_data_str}

    Use your technical analysis algorithms to identify potential trading opportunities based on this data.
    """


    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo-16k",
        messages=[{"role": "system", "content": prompt}],
        max_tokens=6000
    )

    opportunities = response.choices[0].message.content.strip()

    print_with_voice("Identified trading opportunities:")
    print_with_voice(opportunities)

    try:
        order_params = extract_order_parameters(opportunities)
    except ValueError as e:
        print_with_voice(str(e))
        return

    create_order_based_on_params(order_params)

# main execution
if __name__ == '__main__':
    combined_data = combine_all_data()  # combine data from three CSV files
    identify_opportunities(combined_data)  # identify opportunities based on the combined data
